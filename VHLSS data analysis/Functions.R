#---------------------------------------------------------------------------Introduction------------------------------------------------------------------------------

# # Name: Gia Mien Le
# # Professor Matthew Heun
# # Starting date: June 23, 2022
# # File name: Function.R
# 
# # Description: This file contains all the functions that analyzes VHLSS data from General Statistics Office of Vietnam (GSO). They are divided into
# #              Starting, Filtering data, Analyzing Well-being data, Urban/Rural/Total, Results and graphing. 

# #              Please note that the functions are written rather exclusively for analyzing VHLSS data. Therefore, the documentation describing the functions 
# #              are rather exclusive as well, although some might be generally applicable. That's up to your own discretion on how to proceed with the code.

#-----------------------------------------------------------------------------Starting--------------------------------------------------------------------------------

#' Installing packages
#' @aliases Install_pkg
#' @param pkg_name, name of package to be installed 
#'
#' @description 
#' This function installs packages necessary for data analysis. It's not that smart since 
#' you will be the one manually typing the packages names in the Start_page.R
#' 
#' @details 
#' This function takes in a string in the form of variable name pkg_name and checks whether
#' or not the package is installed. If it is not, it will start the installation process. 
#' If it is installed, it will print out "Package already installed" and stop the process.
#' 
NULL
Install_pkg <- function(pkg_name) {
  if(pkg_name %in% rownames(installed.packages()) == FALSE) {
    print("Package installing...")
    install.packages(pkg_name)
  }
  else {
    print("Package already installed")
  }
}


#' Getting .dta files
#'
#' @param path_name, address of the .dta files 
#'
#' @return a list of all the .dta file names
#' 
#' @description 
#' This function takes  all the .dta file from the address provided in the variable 
#' path_name, and puts them in a list.
#' 
#' @details 
#' The function uses setwd(path_name) to set the main directory in the address where it is 
#' supposed find .dta files. The files will be added to a list using the function
#' list.files(path = ".", pattern = "*.dta"). Since the directory is already predetermined,
#' there is no need to redefine path, hence ".". The pattern "*.dta" just means that we 
#' are including all files in the folder with the .dta ending.
#'
#'
NULL
get_dta_files <- function(path_name) {
  setwd(path_name)

  file_list <- list.files(path = ".", pattern = "*.dta")
  
}


#' Importing population data from .txt file
#' 
#' @param file_path, address of the .txt file
#' 
#' @return a data frame of Vietnam's total, urban, and rural population from 1979 - 2019
#' 
#' @description 
#' A function that imports Vietnam's population data from a .txt file
#' 
#' @details 
#' file_path is a variable that stores the address of the file. 
#' 
#' read_delim(file, sep), where "file" is the address of the file and "sep" is a 
#' delimiter, is a function that reads in .txt files without worries about how you 
#' spaced your files. 
#' 
#' The final results is a data frame as you have organized in your .txt file.
#' 
#' 
NULL
get_pop_data_txt <- function(file_path) {

  pop_data <- read.delim(file_path)
  
  return(pop_data)
}



#' Importing GDP data 
#'
#' @param Year , a custom vector of data years, in this case would be 2010 - 2018
#'
#' @return a data frame of wanted GDP based on countries, years, and types of GDP
#' 
#' @description 
#' A function that takes in an existing data frame in R and filter it to get the final
#' wanted results
#' 
#' @details 
#' Obtained from package pwt10.0 is Penn World Table 10.0, a data frame of relative levels
#' of income, output, input, and productivity of 183 countries between 1950 and 2019.
#' Since there is data for almost every country in the world, I used the filter() function
#' to narrow the "country" and "year" columns down to Vietnam and the years included
#' in the parameter "Year".
#' 
#' There are many ways to calculate GDP, hence many GDP variables, but I decided with
#' the variable name "cgdpe", which is the Expenditure-side real GDP at current PPPs
#' (Purchasing Power Parity). Using the select() function, I picked out the columns 
#' I wanted for the resulting data frame, "year" and "cgdpe".
#'
NULL
get_GDP_data <- function(Year) {
  GDP_df <- filter(pwt10.0, country == "Viet Nam" & year %in% Year )
  GDP_df <- select(GDP_df, c("year", "cgdpe"))
  
  return(GDP_df)
}
#------------------------------------------------------------------------Filtering data------------------------------------------------------------------------------

#' Importing .dta files 
#'
#' @param file_list , a list of .dta file names generated by using function
#' get_dta_files(path_name)
#' 
#' @param file_path , the .dta files address
#'
#' @return a list of imported .dta files in R
#' 
#' @description 
#' A function that reads a list of .dta files into R as dataframes.
#' 
#' @details 
#' There are some notes about the functions used in this function.
#' 
#' \describe{
#' \item{lapply(X, FUN)}{
#' 
#' lapply(X, FUN) is used when you want to apply the exact same function to every variable 
#' in the list. Yes, it is a shorter and more concise version of a for-loop. As you
#' can see from the code below, "X" is the list you want to use, "FUN" is the function
#' that you need to define. The "FUN" format seems like you are declaring a function
#' with parameters, in this case, the parameter is one_dta_file, which is a .dta file name
#' from the list. Since you want to apply the function to every variable in the list,
#' you call one variable each time, until the function goes through every single element
#' in your list. 
#' }
#' \item{read_dta} {
#' 
#' There are different versions of Stata (.dta). R reads all those .dta files using differnt
#' functions from different packages depending on the versions of Stata. The version I
#' am using in this function works for Stata versions 5 - 12.
#' 
#' \itemize{
#' \item read.dta("data_name.dta") --> Package: foreign --> handles Stata versions 1-4
#' \item read_dta("data_name.dta") --> Package: haven --> handles Stata versions 5-12
#' \item read.dta13("data_name.dta") --> Package: readstata13 --> handles Stata version 13 and above
#' } 
#' 
#' You can use the newer version function for the older, it should give you some wonkey
#' results, but that should not be a problem. The other way around, however, will
#' cause an error.
#' 
#' Additionally, .name_repair = "unique" just makes sure that there are no duplicate files.
#' }
#' 
#' }
#' 
NULL
import_dta_files <- function(file_list, file_path) {
    setwd(file_path)
    conv_file <- lapply(X = file_list, FUN = function(one_dta_file) {
      haven::read_dta(one_dta_file, .name_repair = "unique")
    })
}



#' Naming data frames 
#'
#' @param data_list , a list of file names
#' 
#' @param conv_data_list , a list of converted .dta files into R data frames using
#' the function import_dta_fules(file_path)
#'
#' @return a list of R data frames with names from the .dta file name list.
#' 
#' @description 
#' A function that puts name on newly imported data frames. They are in form of lists.
#' 
#' @details 
#' First, I need to make sure that the name list and the data frame list are of the same 
#' length. Different lengths would be a bit of an issue since I am expecting that all 
#' indices from one list to match all indices of the other.
#' 
#' The set_names(x, nm) function applies a vector (or list) of names to a vector (or list)
#' of elements. Parameters "x" is a vector (or list) that needs names, and "nm" is a vector 
#' (or list) of names. This function is from "magrittr" package.
#' 
#' You can write the command line this way: set_names(conv_data_list, data_list)
#' The way it was written in the function conv_data_list %>% magrittr::set_names(data_list)
#' has a pipeline characteristics that makes the code more readable.
#'
#' 
NULL
name_dataframes <- function(data_list, conv_data_list) {
  if (length(data_list) != length(conv_data_list)) {
    stop("Why are the lengths different in name_dataframes()?")
  }
  conv_data_list %>%
    magrittr::set_names(data_list)
}



# Function to get all the household samples
#' Create a data frame of all household samples
#'
#' @param hh_list , a list of VHLSS named data frame
#'
#' @return 
#' new_df, a data frame that with the identifications of all households participating in the 
#' survey.
#'
#' @description 
#' This is a function that takes in a list of data frames of all VHLSS sections and
#' output a data frame that contains unique and non-empty cells household identifications
#' for all household samples in the survey.
#' 
#' @details 
#' Since there are data frames that would have unnecessary household sample data, I 
#' made an if-statement, stating that if any data frame from the input list belonged to 
#' the vector of unnecessary household sample data, I assign that element to NULL.
#' That would completely eliminate the data frame.(I was only doing this to reduce the 
#' work load my PC was handling. The whole process for this function to run took an hour.
#' If you have a better solution, please work on it.)
#' 
#' All remaining data frames are filtered down to maintaining only their household 
#' identifications, which are tinh, huyen, xa, diaban, hoso. They can roughly be translated
#' as province, district, commune, territory, house code. 
#' 
#' The bind_rows(df1, df2) function basically combine the rows of two data frames.
#' Therefore, I first assigned "new_df" to the first filtered household data frame in the newly 
#' sorted list. I just wanted to make sure that there are no errors when combining with an
#' empty data frame. With "new_df" and using the for-loop, I repeated the process of adding rows
#' of filtered data frames. 
#' Using the function unique(), I made sure that none of the household IDs are duplicated.
#' This gives me a final data frame of all the households that participated in the living
#' standards survey.
#' 
#'
NULL
Total_sample_household <- function(hh_list) {
  for (name in names(hh_list)) {
    if (name %in% c("wt2014.dta", "oldHO1.dta", "wrongcalculationHO3.dta", "Ho_79.dta", "Ho_87.dta", 
                    "Ho_92.dta", "Ho_89.dta", "MUC4D_VHLSS.dta", "HO1.dta", "HO3.dta", "HO4.dta")) {
      hh_list[[name]] <- NULL
    }
  }
  new_df <- select(hh_list[[1]], c("tinh", "huyen", "xa", "diaban", "hoso"))
  for (x in 2:length(hh_list)) {
    new_df <- unique(bind_rows(new_df, select(hh_list[[x]], c("tinh", "huyen", "xa", "diaban", "hoso"))))
  }
  new_df <- unique(new_df)
  
  return(new_df)
}



# Function to add expenditure rows to get the most complete sample data.
#' Create a data frame of all household samples in VHLSS survey section 3 data list.
#'
#' @param exp_list , a custom list of data frames names with expenditure data 
#' @param folder_list , a list of all VHLSS data frames.
#'
#' @return a data frame of household IDs of all households participated in section 3
#' of the survey.
#' 
#' @description 
#' This function help sorts out households that participated in section 3 of the survey
#' 
#' @details 
#' I let the function go through each element in the input list of data frames using 
#' a for-loop. Since the name of each data frame comes in all forms and sizes, I used 
#' tolower() function to de-capitalize them so that they match the format of list
#' variables in List.R. The names() function basically calls the name of the variable in
#' the list. If the names of data frames in the list exists within the list of section 3
#' data frames names, I will add the rows of that data frame to the internally assigned 
#' empty data frame new_df1, but only when the data frame is filter down to the columns
#' that has household IDs, tinh, huyen, xa, diaban, hoso, using the select() function.
#' 
#' Unlike Total_sample_household() function where I assigned filled in the newly assigned 
#' data frame, I just added new data frames into the empty one. I guess bind_rows() function
#' can add rows of a data frame to an empty data frame. Please correct me if I'm wrong.
#' 
#' unique() function makes sure that none of the rows are duplicated, and the drop_na()
#' function makes sure that no row has an empty cell. I assigned another new data frame 
#' new_df2 to the unique and filled version of new_df1. 
#' 
#' The print functions helps print what you want to the console. In this case, please ignore
#' the print function. I only added them since I want to get a sense of how many rows I have dropped
#' and the percentage of rows that I dropped.
#'
NULL
Add_exp_rows <- function(exp_list, folder_list) {
  new_df1 <- data.frame()
  
  for (x in 1:length(folder_list)) {
    if(tolower(names(folder_list[x])) %in% exp_list) {
      new_df1 <- bind_rows(new_df1, data.frame(select(folder_list[[x]], c("tinh", "huyen", "xa", "diaban", "hoso"))))
    }
  }
  new_df2 <- unique(drop_na(new_df1))
  
  print(paste(exp_list))
  print(nrow(new_df1))
  print(nrow(new_df2))
  print(percent((nrow(new_df1) - nrow(new_df2))/nrow(new_df1)))
  
  return(new_df2)
}



#Adding lists function
#' Adding variables from a list to a different list
#'
#' @param ex_list , a original list of variables to add to (the list already 
#' have existing variables)
#' @param add_list , a list of variables you would want to add to ex_list
#' 
#' @return ex_list, at this point, a new list of variables, both original and added
#' 
#' @description 
#' This function adds variables to an existing list with variables from a different list
#' of choice.
#' 
#' 
#' @details
#' I go through all the elements in add_list. If that element already exists in ex_list,
#' I print to a screen of a rejection. If the element does not exist in ex_list, I use
#' append() function to add the element to the ex_list.
#' 
#'
NULL
Add_list <- function(ex_list, add_list) {
  
  for (obj in add_list) {
    if (obj %in% ex_list) {
      print("Object already exists. Reject!")
    }else{
      print("Object does not exist. Commence addition...")
      ex_list <- append(ex_list, obj)
      print("Added!")
    }
  }
  return(ex_list)
}


# This functions deals with if it is a list of lists
#' Add_list() but for lists contained in a list
#'
#' @param ex_list , a original list of variables to add to (the list already 
#' have existing variables)
#' @param Big_list a list of lists of variables you want to add to ex_list
#'
#' @return a new list of variables, both original and added.
#'
#' @description
#' A function similar to and uses Add_list(), but used on a list of lists.
#' 
#' @details 
#' I simply apply Add_list() function to every list in the Big_list. The outcome would
#' be a new list of both the original variables and newly added variables.
#'
NULL
make_list <- function(ex_list, Big_list) {
  for (obj in Big_list) {
      ex_list <- Add_list(ex_list, obj)
  }
  return(ex_list)
}




# Combining all possible population data in the given list
#' Extract household samples involved in the expenditure survey
#'
#' @param WB_list , a list of data frames (in this case, with expenditure data
#' and human well-being related data from the survey)
#'
#' @return a data frame of households that participated in the expenditure survey and
#' human well-being related survey.
#' 
#' @description 
#' A function that takes in a list of expenditure data frames and human well-being data and 
#' filter them to have the households that participate in the expenditure survey.
#' 
#' @details 
#' \describe{
#' \item {Creating a of dataframes with only household identity} {
#' 
#' I created an empty list variable called new_list, a cnt variable to keep count
#' of the iteration, and an empty data frame called pop_data.
#' 
#' With the for-loop, I go through every single data frame in WB_list, filter them down
#' to the first five columns (those columns are household identifications), and add them to the
#' the new_list with cnt as the iterative index number. To call a variable from a list 
#' (in this case), you need to use the format "list_name[[index_number]]".
#' 
#' I should have documented the code right after I had written. But I did not, and now
#' I have no idea why I put an if-statement to see whether the new_list is empty before
#' adding a data frame into it. That part is unnecessary and redundant.
#' }
#' 
#' \item {Filtering out households with the most complete data} {
#' 
#' The inner_join() function merges two data frames and only return rows that matches 
#' from both data frames.
#' So, I have the first data frame in new_list duplicate-free and all identifications filled
#' and assigned to pop_data (the empty data frame created in the beginning).
#' 
#' I created a for-loop with the iteration number starting at 2 since I already have
#' the first data frame assigned to pop_data. As the loop processes, pop_data will merge 
#' with the next data frame in the list. That new data frame will be re-assigned to 
#' pop_data. And so on. 
#' 
#' Unique() is used to get rid of duplicated rows. Drop_na() is used to eliminate 
#' incomplete household identification rows. 
#' }
#' }
#' 
#' Once again, please ignore the print() statements. They are for monitoring the number
#' of rows (or samples) dropped during the process.
#' 
#' Other BIG NOTE: Sample_ext() is a function that complements Sample_data
#'
NULL
Sample_ext <- function(WB_list) {
  new_list <- list()
  cnt = 1
  pop_data <- data.frame()
  
  for (obj in 1:length(WB_list)) {
    if (length(new_list) == 0) {
      new_list[[cnt]] <- data.frame(select(WB_list[[obj]], c(1:5)))
      cnt = cnt + 1
    } else {
      new_list[[cnt]] <- data.frame(select(WB_list[[obj]], c(1:5)))
      cnt = cnt + 1
    }
    
  }
  
  print(c("Before:", nrow(new_list[[1]])))
  pop_data <- drop_na(unique(new_list[[1]]))
  print(c("After:", nrow(pop_data)))
  
  print(length(new_list))
  
  for (x in 2:length(new_list)) {
    print(c("Before:", nrow(pop_data)))
    pop_data <- unique(drop_na(data.frame(inner_join(pop_data, new_list[[x]]))))
    print(c("After:", nrow(pop_data)))
  }
  
  print(length(new_list))
  print(length(WB_list))
  
  print(c("Finally,", nrow(pop_data)))
  return(pop_data)
  
}



# Initial Filtering population data
#' Creating a data frame of complete household samples
#'
#' @param data_list , list of VHLSS data frames
#' @param name_list , list of data frame names related to expenditure and human well-being
#' @param exp_df1 , education expenditure data frame
#' @param exp_df2 , survey section 3 data frame
#'
#' @return a data frame of complete household samples
#' 
#' @description
#' This function takes in a list of VHLSS data frames, list of data frame names relevant to
#' the research, education expenditure data frame, and survey section 3 data frame and combine
#' them into a data frame of complete household samples.
#' 
#' @details 
#' I create an empty list and called it init_list1. This will be the list where I will store
#' all data frames relevant to the human well-being research. 
#' 
#' The for-loop will iterate through each data frame in the data_list, which is a list
#' of all imported VHLSS data frames. For each iteration, each will compare whether the name
#' of that data frame matches with the data name in the name_list since name_list is a list
#' of names of data frames relevant to the human well-being research.
#' If the name does not match, the iteration will print a statement "Skip object!" and move on.
#' If the name matches, the function will add that data frame (not data frame name) into 
#' init_list1.
#' 
#' The results from Sample_ext() is assigned to sample_df data frame. 
#' new_sample_df data frame merges with exp_df1 and exp_df2, which are education expenditure data frame
#' and survey section 3 data frame, using inner_join() and outputting a data frame with rows that
#' matches.
#' 
#' The final result is a data frame of the most complete household sample data (for now).
#'
#' @examples
Sample_data <- function(data_list, name_list, exp_df1, exp_df2) {
  
  init_list1 <- list()
  
  for (x in seq(1, length(data_list))) {
    for (obj in name_list) {
      if (identical(tolower(names(data_list[x])), obj)==FALSE) {
        print("Skip object!")
      }else{
        init_list1 <- append(init_list1, data_list[x])
        print("Success")
      }
    }
  }
  
  sample_df <- Sample_ext(init_list1)
  
  print(c("BEFORE:", nrow(sample_df)))
  
  new_sample_df <- inner_join(inner_join(sample_df, exp_df1), exp_df2)
  
  print(c("AFTER:", nrow(new_sample_df)))
  
  return(new_sample_df)
  
  
}




# Column extraction for 2012 household data
HH_2012_data_ext <- function(dataframe, ind_min, ind_max, short_str) {
  v_df <- data.frame(subset(dataframe, select = c("tinh", "huyen", "xa", "diaban", "hoso")))
  emp_list = list()

  for (obj in colnames(dataframe)) {
    if (substr(obj,ind_min,ind_max) == short_str) {
      if (!substr(obj, ind_min, ind_max) %in% emp_list) {
        emp_list <- append(emp_list, obj)
      }
    }
  }

  for (obj in emp_list) {
    print(obj)
    v_df <- cbind(data.frame(v_df, subset(dataframe, select = obj)))
  }

  n_df <- pivot_longer(v_df, starts_with(short_str), names_to = "Code name", values_to = short_str)

  return(n_df)
}


#Function to clean up 2012 data
HH_2012_data_filter <- function(HH_data, WB_list, colname_list) {
  obj_str = " "
  df <- data.frame()
  ext_list <- list()
  ind_min = 1

  for (obj in names(HH_data)) {
    if (tolower(obj) %in% WB_list) {
      obj_str <- obj
      print(obj_str)
    }else{
      print("Object does not exist")
    }
  }

  df <- HH_data[[obj_str]]
  
  for (x in 1:length(colname_list)) {
    ext_list[[x]] <- HH_2012_data_ext(df, ind_min, nchar(colname_list[[x]]), colname_list[[x]])
    print("Last track")
  }

  v_df <- data.frame(subset(ext_list[[1]], select = c("tinh", "huyen", "xa", "diaban", "hoso")))
  for (x in 1:length(ext_list)) {
    v_df <- cbind(data.frame(v_df, ext_list[[x]] %>% select(last_col())))
  }
  
  print(c("Before:", nrow(v_df)))
  v_df2 <- unique(drop_na(v_df))
  print(c("After:", nrow(v_df2)))
  
  return(v_df2)
}


# Function to extract necessary columns for a dataframe
Ext_data <- function(HH_data, WB_list, colname_list) {
  
  for (obj in names(HH_data)) {
    if (tolower(obj) %in% WB_list) {
      new_df <- data.frame(cbind((select(HH_data[[obj]], c("tinh", "huyen", "xa", "diaban", "hoso"))),
                                 (select(HH_data[[obj]], colname_list))))
    }
  }
  
  return(new_df)
}


# Function that gets rid of all the empty cells and repeated rows of a dataframe.
Filter_data <- function(HH_data, WB_list, colname_list) {
  new_df <- Ext_data(HH_data, WB_list, colname_list)
  
  print(c("Before:", nrow(new_df)))
  new_df2 <- unique(drop_na(new_df))
  print(c("After:", nrow(new_df2)))
  
  return(new_df2)
}



# Function that combines household and education data
Comb_edu_hh <- function (Edu_data, HH_data) {
  Edu_hh <- data.frame(inner_join(HH_data, Edu_data, by = c("Province", "District", "Commune", "Territory", "House.code", "Member.code")))
  
  print(c("Before:", nrow(Edu_hh)))
  new_Edu_hh <- unique(drop_na(Edu_hh))
  print(c("After:", nrow(new_Edu_hh)))
  
  new_df <- filter(new_Edu_hh, Relationship %in% c(1,2))
  
  return(new_df)

}


# Function that combines electricity and all types of fuels together
Comb_fuel <- function(Fuel_data, fuel_list, code_list, Elec_data) {
  sub_Fuel_data <- data.frame(drop_na(unique(subset(Fuel_data, select = c("Province", "District", "Commune", "Territory", "House.code")))))
  sub_Elec_data <- data.frame(drop_na(unique(subset(Elec_data, select = c("Province", "District", "Commune", "Territory", "House.code")))))
  
  new_sub_Elec_data <- data.frame(inner_join(sub_Fuel_data, sub_Elec_data))
  new_Elec_data <- data.frame(inner_join(new_sub_Elec_data, Elec_data, by = c("Province", "District", "Commune", "Territory", "House.code")))
  
  new_Fuel_data <- data.frame(inner_join(new_sub_Elec_data, Fuel_data, by = c("Province", "District", "Commune", "Territory", "House.code")))
  new_Fuel_data <- filter(new_Fuel_data, Product.code %in% code_list)

  new_Fuel_data$Product.code <- as.character(new_Fuel_data$Product.code)

  for (x in 1:length(code_list)) {

    new_Fuel_data$Product.code[new_Fuel_data$Product.code == code_list[x]] <- fuel_list[x]
  }

  new_fuel_df <- as.data.frame(pivot_wider(new_Fuel_data, names_from = "Product.code", values_from = "Expenditure"))
  new_fuel_df <- unique(unnest(new_fuel_df, fuel_list))
  
  new_fuel_df[is.na(new_fuel_df)] <- 0

  comb_fuel_df <- unique(inner_join(new_fuel_df, new_Elec_data, by = c("Province", "District", "Commune", "Territory", "House.code")))
  comb_fuel_df[is.na(comb_fuel_df)] <- 0
    
  return(comb_fuel_df)
}


#Filter Food data for 2012 and 2014
Food_data_filter <- function (Food_data) {
  Food_data$Food.aid <- as.numeric(Food_data$Food.aid)
  
  print(c("Before:", nrow(Food_data)))
  Food_data <- drop_na(Food_data)
  
  for (x in 1:nrow(Food_data)) {
    val <- Food_data$Food.aid[x]%%(round(Food_data$Food.aid[x]/11, digits = 0)*10) 
    Food_data$Food.aid[x] <- val
  }
  
  print(c("After:", nrow(Food_data)))
  return(Food_data)
}


# Function exclusive to 2016 and 2018 food data.
Filter_2016_food_data <- function(HH_data, WB_list, colname_list, food_df1) {
  food_df2 <- Ext_data(HH_data, WB_list, colname_list)
  print(c("Before:", nrow(food_df2)))
  
  food_df2$m8c1a[is.na(food_df2$m8c1a)] <- 0
  
  food_df <- unique(drop_na(inner_join(food_df1, food_df2, by = c("tinh", "huyen", "xa", "diaban", "hoso"))))
  
  print(c("After:", nrow(food_df)))
  return(food_df)
}


# Filter Food data for 2016
Food_2016_data_filter <- function(Food_2016_data) {
  print(c("Before:", nrow(Food_2016_data)))
  new_food_df <- data.frame(unique(drop_na(filter(Food_2016_data, m8c2maso == 218))))
  new_food_df$m8c2maso <- NULL
  
  print(c("After:", nrow(new_food_df)))
  return(new_food_df)
}


# Dealing with fuel expenditures
Add_fuel_exp <- function (fuel_data) {
  fuel_data$'Expenditure 1'[is.na(fuel_data$'Expenditure 1')] <- 0
  fuel_data$'Expenditure 2'[is.na(fuel_data$'Expenditure 2')] <- 0
  fuel_data$'Expenditure 3'[is.na(fuel_data$'Expenditure 3')] <- 0
  
  print(c("Before:", nrow(fuel_data)))
  fuel_data$Expenditure <- rowSums(fuel_data[, c("Expenditure 1", "Expenditure 2", "Expenditure 3")])
  
  fuel_data$'Expenditure 1' <- NULL
  fuel_data$'Expenditure 2' <- NULL
  fuel_data$'Expenditure 3' <- NULL
  
  new_df <- drop_na(fuel_data)
  print(c("After:", nrow(fuel_data)))
  
  return(fuel_data)
}

# Function to inner_join urban/rural data with normal population data
join_area_sample <- function(area_data, sample_data) {
  new_df <- inner_join(area_data, sample_data, by = c("Province", "District", "Commune", "Territory", "House.code"))
  
  print(c("Before:", nrow(new_df)))
  new_df2 <- unique(drop_na(new_df))
  print(c("After:", nrow(new_df2)))
  
  return(new_df2)
}
#-------------------------------------------------------------------Analyzing Well-being data------------------------------------------------------------------------

# Function that sorts out education indicator based on well-being criteria.
Total_WB_edu_data <- function(Edu_hh_data, Pop_data, Mar_stat_list) {
  
  Edu_hh_data$Member.code <- NULL
  
  # new_df <- Edu_hh_data
  
  new_df <- inner_join(Edu_hh_data, Pop_data, by = c("Province", "District", "Commune", "Territory", "House.code"))
  if(length(Pop_data) == 6) {
    new_df <- new_df %>% relocate(Urban.Rural, .after = House.code)
  }
  print(nrow(Pop_data))
  print(nrow(new_df))
  
  new_df$Relationship <- as.character(new_df$Relationship)
  new_df$Relationship[new_df$Relationship == 1] <- "Household.head"
  new_df$Relationship[new_df$Relationship == 2] <- "Spouse"
  
  new_df$Marital.status <- as.character(new_df$Marital.status)
  new_df$Grade.completed <- as.numeric(new_df$Grade.completed)
  
  for (x in 1:length(c(1:5))) {
    new_df$Marital.status[new_df$Marital.status == c(1:5)[x]] <- Mar_stat_list[x]
  }
  
  #total_df <- as.data.frame(pivot_wider(new_df, names_from = "Relationship", values_from = "Grade.completed"))
  
  married_df <- as.data.frame(pivot_wider(filter(new_df, Marital.status == Mar_stat_list[2]),
                                    names_from = "Relationship", values_from = "Grade.completed"))

  print(c("Before:", length(married_df)))
  new_married_df <- drop_na(unnest(married_df, c(Household.head, Spouse)))
  print(c("After:", nrow(new_married_df)))
  
  WB_married_df <- filter(new_married_df, Household.head >= 9 & Spouse >= 9)
  WB_married_notmet_df <- filter(new_married_df, Household.head < 9 | Spouse < 9)

  other_marstat_df <- as.data.frame(pivot_wider(filter(new_df, Marital.status != Mar_stat_list[2]),
                                          names_from = "Relationship", values_from = "Grade.completed"))

  new_other_marstat_df <- unnest(other_marstat_df, Household.head)
  new_other_marstat_df$Spouse <- NULL
  print(c("Before:", nrow(new_other_marstat_df)))
  new_other_marstat_df <- drop_na(new_other_marstat_df)
  print((c("After:", nrow(new_other_marstat_df))))
  WB_other_marstat_df <- filter(new_other_marstat_df, Household.head >= 5)
  WB_other_marstat_notmet_df <- filter(new_other_marstat_df, Household.head < 5)
  
  total_df <- full_join(new_married_df, new_other_marstat_df)
  
  WB_edu_df <- full_join(WB_married_df, WB_other_marstat_df)
  WB_notmet_df <- full_join(WB_married_notmet_df, WB_other_marstat_notmet_df)
  

  final_list <- list(total_df, WB_edu_df, WB_notmet_df)
  
  return(final_list)
}


# Function that sorts out water indicator based on well-being criteria
Total_WB_water_data <- function(Water_data, Pop_data, safe_water, unsafe_water, safe_water_code, unsafe_water_code) {
  
  new_df <- inner_join(Water_data, Pop_data, by = c("Province", "District", "Commune", "Territory", "House.code"))
  print(c("Before:", nrow(new_df)))
  new_df <- unique(drop_na(new_df))
  print(c("After:", nrow(new_df)))
  
  if (length(Pop_data) == 6) {
    new_df <- new_df %>% relocate(Urban.Rural, .after = House.code)
    new_df[, 7] <- as.character(new_df[, 7])
    
    if(length(Water_data) == 6) {
      safe_water_df <- filter(new_df, Main.water.source %in% safe_water_code)
      unsafe_water_df <- filter(new_df, Main.water.source %in% unsafe_water_code)
      
    }else if (length(Water_data) == 7){
      new_df[, 8] <- as.character(new_df[, 8])
      safe_water_df <- filter(new_df, Main.water.source.for.food %in% safe_water_code & Main.water.source.for.activities %in% safe_water_code)
      unsafe_water_df <- filter(new_df, Main.water.source.for.food %in% unsafe_water_code | Main.water.source.for.activities %in% unsafe_water_code)
    }
  }else if (length(Pop_data) == 5){
  new_df[, 6] <- as.character(new_df[, 6])
  if(length(Water_data) == 6) {
    safe_water_df <- filter(new_df, Main.water.source %in% safe_water_code)
    unsafe_water_df <- filter(new_df, Main.water.source %in% unsafe_water_code)
    
  }else if (length(Water_data) == 7){
    new_df[, 7] <- as.character(new_df[, 7])
    safe_water_df <- filter(new_df, Main.water.source.for.food %in% safe_water_code & Main.water.source.for.activities %in% safe_water_code)
    unsafe_water_df <- filter(new_df, Main.water.source.for.food %in% unsafe_water_code | Main.water.source.for.activities %in% unsafe_water_code)
  }
  }
  
  final_list <- list(new_df, safe_water_df, unsafe_water_df)
  
  return(final_list)
  
}

# Function that sorts out food aid indicator based on well-being criteria
Total_WB_food_data <- function(Food_data, Pop_data) {
  new_df <- inner_join(Food_data, Pop_data, by = c("Province", "District", "Commune", "Territory", "House.code"))
  
  print(c("Before:", nrow(new_df)))
  new_df <- unique(drop_na(new_df))
  print(c("After:", nrow(new_df)))
  
  if(length(Pop_data) == 6) {
    new_df <- new_df %>% relocate(Urban.Rural, .after = House.code)
  }
  
  if (length(Food_data) == 8) {
  
    new_df$Food.aid <- as.numeric(new_df$Food.aid)
    new_df$Food <- as.numeric(new_df$Food)
    new_df$Food.stuff <- as.numeric(new_df$Food.stuff)
    
    WB_food_df <- filter(new_df, Food.aid != 1 & Food >= 2 & Food.stuff >= 2 )
    food_pov_df <- filter(new_df, Food.aid == 1 | Food < 2 | Food.stuff < 2)
    

  }else if (length(Food_data) == 7) {
    
    new_df$Food.aid <- as.numeric(new_df$Food.aid)
    new_df$Enough.food <- as.numeric(new_df$Enough.food)
    
    WB_food_df <- filter(new_df, Food.aid != 1 & Enough.food == 0)
    food_pov_df <- filter(new_df, Food.aid == 1 | Enough.food != 0)
    
  }
  
  final_list <- list(new_df, WB_food_df, food_pov_df)
  
  return(final_list)
}


# Function that sorts out modern fuel indicator based on well-being criteria
Total_WB_fuel_data <- function(Fuel_data, Pop_data, fuel_list, modern_fuel, other_fuel) {
  new_df <- inner_join(Fuel_data, Pop_data, by = c("Province", "District", "Commune", "Territory", "House.code"))

  print(c("Before:", nrow(new_df)))
  new_df <- unique(drop_na(new_df))
  print(c("After:", nrow(new_df)))
  
  if(length(Pop_data) == 6) {
    new_df <- new_df %>% relocate(Urban.Rural, .after = House.code)
  }
  
  new_df$'All fuel Sum' = rowSums(new_df[,fuel_list])
  new_df$'Modern fuel' = rowSums(new_df[, modern_fuel])
  new_df$'Other fuel' = rowSums(new_df[, other_fuel])

  print(c("Before:", nrow(new_df)))
  
  for (x in 1: nrow(new_df)) {
    if (new_df[x, "All fuel Sum"] == 0) {
      new_df <- new_df[-c(x),]
    }
  }
  
  print(c("After:", nrow(new_df)))
  
  percent <- unlist(apply(new_df, 1, function(x) {round(x["Modern fuel"]/x["All fuel Sum"], 1)}))
  new_df$Percent <-percent

  WB_Fuel_data <- filter(new_df, Percent >= 0.5)
  other_fuel_data <- filter(new_df, Percent < 0.5)

  final_list <- list(new_df, WB_Fuel_data, other_fuel_data)
  
  return(final_list)

}

#----------------------------------------------------------------------Urban/Rural/Total---------------------------------------------------------------------
# Function to filter urban or rural areas
urban_rural_filter <- function(data_list, string) {
  if (string == "urban") {
    for (x in 1:length(data_list)) {
      data_list[[x]] <- filter(data_list[[x]], Urban.Rural == 1)
    }
  }else if (string == "rural") {
    for (x in 1:length(data_list)) {
      data_list[[x]] <- filter(data_list[[x]], Urban.Rural == 2)
    }
  }else{
    print("Invalid answer")
  }
  return(data_list)
}


# Function to add member code to the well-being dataframes
add_member_code <- function(member_data, data_list) {
  member_data <- select(member_data, c("Province", "District", "Commune", "Territory", "House.code", "Member.code"))
  for (x in 1:length(data_list)) {
    data_list[[x]] <- unique(select(data_list[[x]], c("Province", "District", "Commune", "Territory", "House.code")))
    data_list[[x]] <- inner_join(data_list[[x]], member_data, by = c("Province", "District", "Commune", "Territory", "House.code"))
    data_list[[x]] <- data_list[[x]] %>% relocate(Member.code, .after = House.code)
  }
  
  return(data_list)
}
#----------------------------------------------------------------------------Results--------------------------------------------------------------------------

# Function that picks out the necessary data sets
data_set_choice <- function(dataframe, colnames, year) {
  dataframe <- select(dataframe, colnames)
  dataframe <- filter(dataframe, dataframe$Year %in% as.numeric(year))
}


# Function that displays the final results of well-being indicator
Results_WB <- function(WB_list, total_df, vcolnames) {
  
  cnt = 1
  
  for(obj in WB_list) {
    total <- nrow(obj[[1]])
    WB_met <- nrow(obj[[2]])
    WB_notmet <- nrow(obj[[3]])
    percentage <- round(WB_met/total, digits = 4)
    scale <- percentage*total_df[cnt, 2]
    
    total_df[cnt, 'Total'] <- total
    total_df[cnt, 'WB.met'] <- WB_met
    total_df[cnt, 'WB.not.met'] <- WB_notmet
    total_df[cnt, 'WB.Percent'] <- percentage
    total_df[cnt, "Pop scale"] <- scale
    
    cnt = cnt + 1
  }
  
  total_df$WB.Percent <- percent(total_df$WB.Percent)
  
  colnames(total_df) <- vcolnames
  
  return(total_df)
}


Combine_dataframe <- function(WB_list, total_df, number_or_sample) {
  if (number_or_sample == "sample") {
    total_df <- select(total_df, c("Year"))
    for (x in 1:length(WB_list)) {
      choice <- data.frame(select(WB_list[[x]], c(starts_with("Sample.Percent."), starts_with("Samples."))))
      total_df <- cbind(total_df, choice)
    }
  }else if (number_or_sample == "number") {
    for (x in 1:length(WB_list)) {
      choice <- data.frame(select(WB_list[[x]], c(contains("Number.Percent"), starts_with("Numbers."), last_col())))
      total_df <- cbind(total_df, choice)
    }
  }
  names(total_df)[names(total_df) == "Population"] <- "Total Population"
  return(total_df)
}

Add_total_population <- function (pop_df, Rural_list, Urban_list, number_or_sample) {
  
  if (number_or_sample == "sample") {
    total_df <- select(pop_df, c("Year"))
    for (x in 1:length(Rural_list)) {
    total_df <- cbind(total_df, select(Rural_list[[x]], c(3)) + select(Urban_list[[x]], c(3)))
    total_df <- cbind(total_df, (select(Rural_list[[x]], c(4)) + select(Urban_list[[x]], c(4)))/(select(Rural_list[[x]], c(3)) + select(Urban_list[[x]], c(3))))
    }

  } else if(number_or_sample == "number") {
    total_df <- pop_df
    for (x in 1:length(Rural_list)) {
      total_df <- cbind(total_df, select(Rural_list[[x]], c(3)) + select(Urban_list[[x]], c(3)))
      total_df <- cbind(total_df, (select(Rural_list[[x]], c(4)) + select(Urban_list[[x]], c(4)))/(select(Rural_list[[x]], c(3)) + select(Urban_list[[x]], c(3))))
      total_df <- cbind(total_df, select(Rural_list[[x]], c(7)) + select(Urban_list[[x]], c(7)))
    }
  }
  
  total_df <- data.table::setnames(total_df, c("Grade completed >= 9", "Safe Water", "Adequate Food", "Modern fuel met"), 
                       c("Percent.WB.Education", "Percent.WB.Water", "Percent.WB.Food", "Percent.WB.Fuel"))
  
  total_df$Percent.WB.Education <- percent(total_df$Percent.WB.Education)
  total_df$Percent.WB.Water <- percent(total_df$Percent.WB.Water)
  total_df$Percent.WB.Food <- percent(total_df$Percent.WB.Food)
  total_df$Percent.WB.Fuel <- percent(total_df$Percent.WB.Fuel)
  
  
  return(total_df)
}


Percent_all_WB_year <- function(pop_df, WB_list, member_data) {

  WB_df <- unique(select(WB_list[[1]][[2]], c("Province", "District", "Commune", "Territory", "House.code")))
  member_data <- select(member_data, c("Province", "District", "Commune", "Territory", "House.code", "Member.code"))

  for (obj in WB_list) {
    obj[[2]] <- unique(select(obj[[2]], c("Province", "District", "Commune", "Territory", "House.code")))
    WB_df <- inner_join(WB_df, obj[[2]], by = c("Province", "District", "Commune", "Territory", "House.code") )
  }
  
  WB_df <- inner_join(WB_df, member_data, by = c("Province", "District", "Commune", "Territory", "House.code")) 
  
  total_num <- nrow(WB_list[[2]][[1]])
  WB_num <- nrow(WB_df)
  percent <- percent(WB_num/total_num)
  scale <- pop_df*percent
  
  results <- c(total_num, WB_num, percent, scale)
  
  return(results)
}


Percent_all_WB <- function(pop_df, WB_all_list) {
  cnt = 1
  total_df <- data.frame()
  for (obj in WB_all_list) {
    total_df[cnt, "Total.WB"] <- obj[1]
    total_df[cnt, "Number.WB"] <- obj[2]
    total_df[cnt, "Percent.WB"] <- obj[3]
    total_df[cnt, "Population.scale"] <- obj[4]
    
    cnt = cnt + 1
  }
  
  total_df <- cbind(pop_df, total_df)
  total_df$Percent.WB <- percent(total_df$Percent.WB)
  
  return(total_df)
}


Add_all_WB_total <- function (pop_df, Rural_df, Urban_df) {
  total_df <- pop_df
  
  total_df$Total.WB <- Rural_df$Total.WB + Urban_df$Total.WB
  total_df$Number.WB <- Rural_df$Number.WB + Urban_df$Number.WB
  total_df$Percent.WB <- total_df$Number.WB/total_df$Total.WB
  total_df$Population.scale <- Rural_df$Population.scale + Urban_df$Population.scale
  
  total_df$Percent.WB <- percent(total_df$Percent.WB)
  
  return(total_df)
}


Percent_sample_dropped <- function(init_sample, final_sample) {
  new_df<- inner_join(init_sample, final_sample, by = c("Year"))
  
  new_df$Reported.Complete <- c(9399, 9402, 9399, 9399, 9399)
  
  new_df$Percent.dropped <- percent((new_df$Total.households - new_df$Final.Sample)/new_df$Total.households)
  
  return(new_df)
}

#---------------------------------------------------------------------------Graphing----------------------------------------------------------------------------
facet_graph <- function(total_df, text, coeff, WB_vector, WB_vector_year) {
  
  total_df$Year <- as.character(total_df$Year)
  
  alter_df <- select(total_df, c("Year", "Scale.Education", "Scale.Water", "Scale.Food", "Scale.Fuel")) %>%
    gather(key = "WB.Indicator", value = "Population", c("Scale.Education", "Scale.Water", "Scale.Food", "Scale.Fuel"))
  
  alter_df2 <- select(total_df, WB_vector_year) %>%
    gather(key = "Percent.WB", value = "Percent.value", WB_vector)
  
  final_df <- cbind(select(alter_df, c("Year", "WB.Indicator", "Population")), select(alter_df2, c("Percent.WB", "Percent.value")))
  
  ggplot(final_df, aes(x = Year, group = 1)) +
    ggtitle(text) +
    geom_col(aes(y = Population/1000000, fill = "Population"), width = 0.5, colour = "black") +
    facet_wrap(~WB.Indicator, labeller = as_labeller(c("Scale.Education" = "Education",
                                                       "Scale.Food" = "Food",
                                                       "Scale.Fuel" = "Fuel",
                                                       "Scale.Water" = "Water"))) +
    geom_line(aes(y = Percent.value*coeff, color = "Percentage"), size = 0.75, linetype = "solid") +
    
    scale_y_continuous(name = "Population (million people)",
                       sec.axis = sec_axis(~./coeff, name = "Well-being achieved (%)", labels = scales::label_percent(),
                                           breaks = seq(0, 1, 0.2)),
                       limits = c(0, coeff),
                       expand = c(0,0),
                       breaks = seq(0, coeff, 20)) +
    scale_fill_manual(values = c("light blue")) +
    scale_color_manual(values = c("red")) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
          axis.ticks.length.y = unit(-0.15, "cm"),
          axis.ticks.x = element_blank(),
          legend.position = "bottom",
          legend.title = element_blank(),
          strip.text = element_text(face = "bold"),
          plot.title = element_text(hjust = 0.5))
}


graph_4_WB <- function(total_df) {
  total_df$Year <- as.character(total_df$Year)
  total_df$Percent.WB <- as.numeric(total_df$Percent.WB)
  
  ggplot(total_df, aes(x = Year, group = 1)) +
    geom_col(aes(y = Population.scale/1000000, fill = "Population"), width = 0.25, colour = "black") +
    geom_line(aes(y = Percent.WB*35, color = "Percentage"), size = 0.75, linetype = "solid") +
    scale_y_continuous(name = "Population (million people)",
                       sec.axis = sec_axis(~./35, name = "Well-being achieved (%)", labels = scales::label_percent(),
                                           breaks = seq(0, 1, 0.2)),
                       limits = c(0, 35),
                       expand = c(0,0),
                       breaks = seq(0, 35, 5)) +
    scale_fill_manual(values = c("light blue")) +
    scale_color_manual(values = c("red")) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length.y = unit(-0.15, "cm"),
          axis.ticks.x = element_blank(),
          legend.title = element_blank(),
          legend.position = "bottom")
}


Percent_WB_one_graph <- function(Urban_all_Summary, Urban_Member_Summary,
                                 Rural_all_Summary, Rural_Member_Summary,
                                 Total_all_Summary, Total_Member_Summary) {
  
  urban_df <- cbind(select(Urban_all_Summary, c("Year", "Percent.WB")), select(Urban_Member_Summary, starts_with('Number.Percent.')))
  colnames(urban_df) <- c("Year", "Percent.WB", "Percent.WB.Education", "Percent.WB.Water", "Percent.WB.Food", "Percent.WB.Fuel")
  urban_df <- add_column(urban_df, Area.type = "Urban", .after = "Year")
  
  rural_df <- cbind(select(Rural_all_Summary, c("Year", "Percent.WB")), select(Rural_Member_Summary, starts_with('Number.Percent.')))
  colnames(rural_df) <- c("Year", "Percent.WB", "Percent.WB.Education", "Percent.WB.Water", "Percent.WB.Food", "Percent.WB.Fuel")
  rural_df <- add_column(rural_df, Area.type = "Rural", .after = "Year")
  
  total_df <- cbind(select(Total_all_Summary, c("Year", "Percent.WB")), select(Total_Member_Summary, starts_with('Percent.')))
  total_df <- add_column(total_df, Area.type = "Total", .after = "Year")
  
  
  final_df <- rbind(rbind(rural_df, urban_df), total_df)
  
  final_df <- gather(final_df, key = "WB.Indicator", value = "Percent", c("Percent.WB", "Percent.WB.Education", "Percent.WB.Water",
                                                                          "Percent.WB.Food", "Percent.WB.Fuel"))
  
  final_df$Area.type <- factor(final_df$Area.type, level = c("Rural", "Urban", "Total"))
  final_df$WB.Indicator <- factor(final_df$WB.Indicator, level = c("Percent.WB", "Percent.WB.Education",
                                                                   "Percent.WB.Water", "Percent.WB.Food", "Percent.WB.Fuel"))
  
  ggplot(final_df, aes(x = Year, y = Percent)) +
    geom_line(aes(color = WB.Indicator, linetype = WB.Indicator), size = 0.75) +
    facet_wrap(~Area.type) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length = unit(-0.15, "cm"),
          strip.text = element_text(face = "bold"),
          legend.title = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    scale_y_continuous(name = "% Population achieved well-being",
                       labels = scales::label_percent(),
                       limits = c(0, 1),
                       expand = c(0, 0),
                       breaks = seq(0, 1, 0.2)) +
    scale_linetype_manual(labels = c('All Well-being indicators', 'Education', 'Water', 'Food', 'Fuel'),
                          values = c("solid", "dashed", "dashed", "dashed", "dashed")) +
    scale_color_manual(labels = c('All Well-being indicators', 'Education', 'Water', 'Food', 'Fuel'),
                       values = c("red", "orange", "blue", "maroon", "green")) +
    ggtitle("Percent population achieved well-being in rural, urban, and all of Vietnam")
}



Population_one_graph <- function(Urban_all_Summary, Urban_Member_Summary,
                                 Rural_all_Summary, Rural_Member_Summary,
                                 Total_all_Summary, Total_Member_Summary) {
  
  urban_df <- cbind(select(Urban_all_Summary, c("Year", "Urban.Population", "Population.scale")), select(Urban_Member_Summary, starts_with('Scale.')))
  urban_df <- add_column(urban_df, Area.type = "Urban", .after = "Year")
  colnames(urban_df)[which(names(urban_df) == "Urban.Population")] <- "Population"
  
  rural_df <- cbind(select(Rural_all_Summary, c("Year", "Rural.Population", "Population.scale")), select(Rural_Member_Summary, starts_with('Scale.')))
  rural_df <- add_column(rural_df, Area.type = "Rural", .after = "Year")
  colnames(rural_df)[which(names(rural_df) == "Rural.Population")] <- "Population"
  
  total_df <- cbind(select(Total_all_Summary, c("Year", "Population", "Population.scale")), select(Total_Member_Summary, starts_with('Scale.')))
  total_df <- add_column(total_df, Area.type = "Total", .after = "Year")
  
  
  final_df <- rbind(rbind(rural_df, urban_df), total_df)
  
  final_df <- gather(final_df, key = "WB.Indicator", value = "Number", c("Population.scale", "Population", "Scale.Education", "Scale.Water",
                                                                          "Scale.Food", "Scale.Fuel"))
  
  final_df$Area.type <- factor(final_df$Area.type, level = c("Rural", "Urban", "Total"))
  final_df$WB.Indicator <- factor(final_df$WB.Indicator, level = c("Population.scale", "Scale.Education",
                                                                   "Scale.Water", "Scale.Food", "Scale.Fuel", "Population"))
  
  ggplot(final_df, aes(x = Year,y = Number/1000000, fill = WB.Indicator)) +
    geom_col(position = "dodge", width = 1.5, color = "black") +
    facet_wrap(~Area.type) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length = unit(-0.15, "cm"),
          strip.text = element_text(face = "bold"),
          legend.title = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    scale_y_continuous(name = "Number of people achieved well-being (million people)",
                       limits = c(0, 100),
                       expand = c(0, 0),
                       breaks = seq(0, 100, 20)) +
    scale_x_continuous(name = "Year",
                       breaks = seq(2010, 2018, 2)) +
    scale_fill_brewer(labels = c('All Well-being indicators', 'Education', 'Water', 'Food', 'Fuel', 'Total Population'),
                       palette = "Blues") +
    ggtitle("Number of people achieved well-being in rural, urban, and all of Vietnam")
  
}


Sum_graph_4_WB <- function(total_df, urban_df, rural_df){
  total_df$Year <- as.character(total_df$Year)
  
  urban_df <- select(urban_df, c("Percent.WB", "Population.scale"))
  colnames(urban_df) <- c("Urban.WB", "Urban")
  
  rural_df <- select(rural_df, c("Percent.WB", "Population.scale"))
  colnames(rural_df) <- c("Rural.WB", "Rural")
  
  total_df <- select(total_df, c("Year", "Percent.WB", "Population.scale"))
  colnames(total_df) <- c("Year","Total.WB", "Total")
  
  final_df <- cbind(cbind(total_df, urban_df), rural_df)
  
  alter_df <- gather(final_df, key = "Area", value = "Population", c("Total", "Urban", "Rural")) %>% select(c("Year", "Area", "Population"))
  alter_df2 <- gather(final_df, key = "Area", value = "Percent", c("Total.WB", "Urban.WB", "Rural.WB")) %>% select("Percent")
  
  sum_df <- cbind(alter_df, alter_df2)
  
  sum_df$Area <- factor(sum_df$Area, levels = c("Rural", "Urban", "Total"))
  
  ggplot(sum_df, aes(x = Year, group = 1)) +
    geom_col(aes(y = Population/1000000, fill = "Population"), width = 0.25, colour = "black", color = "black") +
    geom_line(aes(y = Percent*35, color = "Percentage"), size = 0.75, linetype = "solid") +
    facet_wrap(~Area, ncol = 3) +
    scale_y_continuous(name = "Population (million people)",
                       sec.axis = sec_axis(~./35, name = "Well-being achieved (%)", labels = scales::label_percent(),
                                           breaks = seq(0, 1, 0.2)),
                       limits = c(0, 35),
                       expand = c(0,0),
                       breaks = seq(0, 35, 5)) +
    scale_fill_manual(values = "light blue") +
    scale_color_manual(values = "red") +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length.y = unit(-0.15, "cm"),
          axis.ticks.x = element_blank(),
          strip.text = element_text(face = "bold"),
          legend.title = element_blank(),
          legend.position = "bottom")
}


sample_graph <- function(percent_sample_df) {
  percent_sample_df$Year <- as.character(percent_sample_df$Year)
  ggplot(percent_sample_df, aes(x = Year, group = 1)) +
    geom_line(aes(y = Final.Sample/1000, linetype = "Analyzed household samples"), size = 1) +
    geom_line(aes(y = Total.households/1000, linetype = "Total household samples"), size = 1) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length = unit(-0.15, "cm"),
          plot.title = element_text(hjust = 0.5),
          legend.title = element_blank(),
          legend.position = "bottom") +
    scale_y_continuous(breaks = seq(0, 120, 20),
                       limits = c(0, 120),
                       expand = c(0,0)) +
    ggtitle("Total vs. Analyzed Household Samples") +
    ylab("Number of households (thousands)")
}



total_population_graph <- function(Pop_data) {
  pop_df <- filter(Pop_data, Year %in% c(2010:2018))
  pop_df$Year <- as.character(pop_df$Year)
  
  pop_df <- gather(pop_df, key = "Area.type", value = "Population", c("Population", "Urban.Population", "Rural.Population"))
  pop_df$Area.type <- factor(pop_df$Area.type, level = c("Rural.Population", "Urban.Population", "Population"))
  
  ggplot(pop_df, aes(x = Year, y = Population/1000000)) +
    geom_col(width = 0.5, fill = "orange", color = "black") +
    facet_wrap(~ Area.type, labeller = as_labeller(c("Population" = "Total",
                                                     "Rural.Population" = "Rural",
                                                     "Urban.Population" = "Urban"))) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length = unit(-0.15, "cm"),
          axis.ticks.x = element_blank(),
          strip.text = element_text(face = "bold"),
          plot.title = element_text(hjust = 0.5)) +
    scale_y_continuous(name = "Population (million)",
                       limits = c(0, 100),
                       expand = c(0, 0),
                       breaks = seq(0, 100, 20)) +
    ggtitle("Vietnam's total, urban, and rural population")
}


GDP_plot <- function(sum_df) {
  alter_df <- melt(sum_df, id.vars = 'year')
  alter_df$variable <- factor(alter_df$variable, level = c("cgdpe", "Population.scale", "Scale.Education",
                                                           "Scale.Water", "Scale.Food", "Scale.Fuel", "Population"))
  
  ggplot(alter_df, aes(x = year, y = value)) +
    geom_line(aes(color = variable, linetype = variable), size = 0.75) +
    scale_linetype_manual(labels = c("GDP", 'All Well-being indicators', 'Education', 'Water', 'Food', 'Fuel', 'Population'),
                          values = c("solid", "solid", "dashed", "dashed", "dashed", "dashed", "dotted")) +
    scale_color_manual(labels = c("GDP", 'All Well-being indicators', 'Education', 'Water', 'Food', 'Fuel', 'Population'),
                       values = c("black", "red", "orange", "blue", "maroon", "green", "black")) +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          axis.ticks.length = unit(-0.15, "cm"),
          legend.title = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    xlab("Year")
}

GDP_index_graph <- function(GDP_WB) {
  sum_df <- GDP_WB
  for (y in 2:length(GDP_WB)) {
    for (x in 1:nrow(GDP_WB)) {
      sum_df[x, y] <- round(sum_df[x, y]/GDP_WB[1, y], 2)
    }
  }
  
  GDP_plot(sum_df) +
    scale_y_continuous(name = "Index ratio",
                       breaks = seq(0, 2.2, 0.2),
                       limits = c(0, 2.2),
                       expand = c(0,0)) +
    ggtitle("GDP index vs. Human well-being index in Vietnam")
  
}


GDP_rate_of_change <- function(GDP_WB) {
  sum_df <- GDP_WB
  
  for (y in 2:length(GDP_WB)) {
    for (x in 1:nrow(GDP_WB)) {
      if (x == 1) {
        sum_df[x, y] <- 0
      }else{
        sum_df[x, y] <- round(((GDP_WB[x, y]/GDP_WB[x-1, y])^(1/(GDP_WB[x, 1] - GDP_WB[x-1, 1]))) - 1, 3)
      }
    }
  }
  
  GDP_plot(sum_df) +
    scale_y_continuous(name = "Growth rate",
                       breaks = seq(0, 0.2, 0.02),
                       limits = c(0, 0.2),
                       expand = c(0,0),
                       labels = scales::label_percent()) +
    ggtitle("GDP growth rate vs. Human well-being growth rate in Vietnam")
  
}